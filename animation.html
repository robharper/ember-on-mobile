<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Mobile Ember</title>

    <meta name="description" content="Using Ember.js for creating native-like mobile apps">
    <meta name="author" content="Rob Harper">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="css/custom.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script src="http://jsbin.com/js/embed.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>


    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <div class="slides">

        <section>
          <h1>Animating Ember</h1>
          <h3>From the beginning</h3>
          <p>
            <small><a href="http://github.com/robharper">Rob Harper</a> / <a href="http://twitter.com/rdharper">@rdharper</a></small>
          </p>
          <p>
            <small>Jan 9, 2014</small>
          </p>
          <a href="http://www.pressly.com"><img class="bare" src="http://d1tv73z3fnbnfg.cloudfront.net/Pressly-logo-small.png"></a>
          <footer class="darken">Press <code>s</code> to see presentation notes</footer>
        </section>

        <section>
          <header>
            <h2>
              Why
              <span class="fragment" data-fragment-index=2><span class="fragment disappear" data-fragment-index=3>bother?</span></span>
              <span class="fragment" data-fragment-index=3>me?</span>
            </h2>
          </header>

          <aside class="notes">
            Why bother?
            <ul>
              <li>Animation is a requirement to make a web app feel like a native app on a mobile device</li>
              <li>Animations help the user preserve context and helps show relationships between application states and actions</li>
            </ul>
            Why me?
            <ul>
              <li>Ember-animated-outlet is a great solution for a set of animation needs (route transitions)</li>
              <li>Adding animation to the core library <a href="http://discuss.emberjs.com/t/animation-support-in-ember-1-1/1977">has been discussed</a>, but it's not trivial to design well</li>
              <li>But at the app level, it's not so hard</li>
            </ul>
          </aside>
        </section>

        <section>
          <header>
            <h2>Animation Goals</h2>
          </header>
          <ul>
            <li>Route Transitions <span class="darken">(back button)</span> <small><code class="darken fragment" data-fragment-index="1">{{outlet}}</code></small></li>
            <li>Modals <small><code class="darken fragment" data-fragment-index="1">ContainerView or {{outlet}}</code></small></li>
            <li>...any view coming in or going out <small><code class="darken fragment" data-fragment-index="1">{{each}}</code></small></li>
          </ul>

          <aside class="notes">
            <ul>
              <li>Route transitions: Navigating data hierarchies complete with back button support</li>
              <li>Modals: Reveal effects</li>
              <li>Lists: deleted items slide away</li>
            </ul>
            <p>Implementing all of these boil down to a single view class: ContainerView. Outlets are containers in which the current route's view is rendered. Lists are CollectionViews, subclasses of a container.</p>
            <p>Let's start with route animation and modals</p>
          </aside>
        </section>

        <section>
          <header>
            <h2 class="as-is">Ember.ContainerView</h2>
          </header>
          
          <pre><code class="javascript">
Ember.ContainerView = Ember.View.extend(Ember.MutableArray, {
  /**
    If you would like to display a single view in your ContainerView, 
    you can set its currentView property. When the currentView property 
    is set to a view instance, it will be added to the ContainerView. If
    the currentView property is later changed to a different view, the
    new view will replace the old view. If currentView is set to null, 
    the last currentView will be removed.
  */  
  currentView: null
});
          </code></pre>
          
          <aside class="notes">
            ContainerView - it manages the lifecycle of views within it: added views are placed
            on the DOM and rendered; removed views are removed from the DOM and destroyed. Its implementation
            has a contains a little sugar for managing a single "currentView" using property binding.
          </aside>
        </section>

        <section>
          <header>
            <h2 class="as-is">Ember.ContainerView</h2>
          </header>
          
          <a class="jsbin jsbin-embed" href="http://jsbin.com/evofESi/8/edit?live,javascript&height=400px">Edit this example</a>

          <aside class="notes">
            Here's the simple test harness we'll use as we develop our animation capabilities. We'll subclass ContainerView and get to work. Clicking within the dotted box will advance through steps of the test case, the test case code for the step will be shown below.
          </aside>
        </section>

        <section>
          <header>
            <h2>Default Behaviour</h2>
          </header>
          
          <p>Old View</p>
          <pre><code data-trim class="javascript">
            container.removeObject( oldCurrentView );
          </code></pre>

          <p>New View</p>
          <pre><code data-trim class="javascript">
            container.addObject( newCurrentView );
          </code></pre>
                    
          <aside class="notes">
            We can boil the parts of ContainerView's handling of currentView that we care about down to these two lines of code. Remember that the ContainerView is managed just like an array. Views added to the array are added to the DOM; views removed from the array are removed from the DOM.
          </aside>
        </section>

        <section>
          <header>
            <h2>Default Behaviour</h2>
          </header>
          
          <a class="jsbin jsbin-embed" href="http://jsbin.com/eJaJujI/3/edit?live,javascript&height=400px">Edit this example</a>

          <aside class="notes">
            Here's our ContainerView subclass with currentView handling reimplemented (copied).
          </aside>
        </section>


        <section>
          <header>
            <h2>Deferring Destruction</h2>
          </header>
          
          <p>Old View</p>
          <pre><code data-trim class="javascript">
Ember.run.later( function() {
  container.removeObject( oldCurrentView );
}, 2000 );
          </code></pre>

          <p>New View</p>
          <pre><code data-trim class="javascript">
            container.addObject( newCurrentView );
          </code></pre>

          <br/>
          <p class="fragment">Recall that <code>ContainerView</code> manages an array of views</p>
          
          <aside class="notes">
            <p>Let's make a simple change to the removal of the view being dismissed. Let's defer that for 2 seconds.</p>
            <p>This is fairly useless but illustrates an important point about the ContainerView: recall that it's an array. Just because currentView only allowed to be a single view at any time, the ContainerView can contain as many views as we like. This is arguably the most important point in this presentation.</p>
          </aside>
        </section>

        <section>
          <header>
            <h2>Deferring Destruction</h2>
          </header>
          
          <a class="jsbin jsbin-embed" href="http://jsbin.com/uvUxEs/2/embed?live,javascript&height=400px">Edit this example</a>

          <aside class="notes">
            Notice how the view being removed now sticks around for 2 seconds before being destroyed.  Clicking quickly can build up a whole queue of views to be destroyed. 
          </aside>
        </section>


        <section>
          <header>
            <h2>Fade Away</h2>
          </header>
          
          <p>Old View</p>
          <pre><code data-trim class="javascript">
oldCurrentView.$().fadeOut( 2000, function() {
  container.removeObject( oldCurrentView );
});
          </code></pre>

          <p>New View</p>
          <pre><code data-trim class="javascript">
            container.addObject( newCurrentView );
          </code></pre>
          
          <aside class="notes">
            Change the deferred removal to a fade out then deferred removal.
          </aside>
        </section>

        <section>
          <header>
            <h2>Fade Away</h2>
          </header>
          
          <a class="jsbin jsbin-embed" href="http://jsbin.com/OmOZIyu/2/embed?live,javascript&height=400px">Edit this example</a>

          <aside class="notes">
          </aside>
        </section>



        <section>
          <header>
            <h2>Fade In</h2>
          </header>
          
          <p>Old View</p>
          <pre><code data-trim class="javascript">
oldCurrentView.$().fadeOut( 2000, function() {
  container.removeObject( oldCurrentView );
});
          </code></pre>

          <p>New View</p>
          <pre><code data-trim class="javascript">
container.pushObject(newView);
newView.one('didInsertElement', function() {
  newView.$().hide().fadeIn(2000);
});
          </code></pre>
          
          <aside class="notes">
            Adding a fade in will allow us to complete a cross-fade effect. Two things to note:
            <ol>
              <li>We have to wait until the new view receives didInsertElement. Until then it is not on the DOM and there isn't an element to fade in</li>
              <li>We need to use a little css to position the views ontop of each other</li>
            </ol>
          </aside>
        </section>

        <section>
          <header>
            <h2>Fade In</h2>
          </header>
          
          <a class="jsbin jsbin-embed" href="http://jsbin.com/ijAFoFa/3/embed?live,javascript&height=400px">Edit this example</a>

          <aside class="notes">
            Quick and dirty cross-fading ContainerView in a few lines of code. It's not production ready because there are a number of edge cases and gotchas to consider (covered later) but it's functional.
          </aside>
        </section>

        <section>
          <h2>Now What?</h2>
          <aside class="notes">
            Our ContainerView can easily handle fading in and out modal views by binding to currentView. But what about route transitions?
          </aside>
        </section>        

        <section>
          <header>
            <h2>Outlets</h2>
          </header>

          <pre><code data-trim>{{outlet viewClass="App.MyAnimatedContainer"}}</code></pre>
          <small class="darken">Routes and Modals</small>
        
          <aside class="notes">
            <p>Luckily all an outlet is is a ContainerView whose currentView is managed by the Ember Router. By specifying the viewClass to use in an outlet we can instruct Ember to use our subclass and our route changes start animating. This also has the effect of animating on the browser's back button - just another route transition.</p>
            <p>Using outlets for modal view containers is also a common pattern and works the same way</p>
          </aside>
        </section>


        <section>
          <header>
            <h2>Effects</h2>
          </header>

          <p>Whole container...</p>
          <pre><code data-trim>{{outlet viewClass="App.MyAnimatedContainer" effect="drop"}}</code></pre>

          <div class="fragment">
            <p>...or by view</p>
            <pre><code data-trim class="javascript">
App.MyAnimatedContainer.defineTransition({
  from: 'some-parent-view',
  to: 'some-child-view',
  effect: 'slideLeft',
  duration: 500
});

App.MyAnimatedContainer.defineTransition({
  from: 'some-child-view',
  to: 'some-parent-view',
  effect: 'slideRight',
  duration: 250
})
            </code></pre>
          </div>
        

          <aside class="notes">
            <p>Before discussing some of the gotchas, let's add features!</p>
            <p>Whole container: We could control the animation effect on the whole container - every view is given the same treatment. Reasonable choice for many cases</p>
            <p>By view: Alternately we could register view-to-view "state transitions"</p>
          </aside>
        </section>


        <section>
          <header>
            <h2>Effects</h2>
          </header>

          <p>Delegate to child views...</p>
          <pre><code data-trim class="javascript">
FadingView = Ember.Mixin.create({
  reveal: function() {
    var self = this;
    return new Ember.RSVP.Promise( function(resolve, reject) {
      self.$().hide().fadeIn(500, resolve);
    });
  }
  dismiss: function() {
    var self = this;
    return new Ember.RSVP.Promise( function(resolve, reject) {
      self.$().fadeOut(500, resolve);
    });
  }
});

MyAlertModal = Ember.View.extend( FadingView, { /* ... */ });
          </code></pre>

          <aside class="notes">
            <p>Delegate: Take the effects out of the container and let the child views themselves handle reveal/dismiss while communicating effect completion with promises (although this still requires style-coordination between incoming and outgoing views, e.g. layout)</p>
          </aside>
        </section>

        <section>
          <header>
            <h2>Effects</h2>
          </header>

          <p>...or CSS3 Transitions</p>
          <table>
            <thead>
              <tr>
                <td>Enter / Leave</td><td>Start</td><td>During</td>
              </tr>
            </thead>
            <tr>
              <td>Enter</td><td><pre>.em-animate .em-enter</pre></td><td><pre>.em-enter-active</pre></td>
            </tr>
            <tr>
              <td>Leave</td><td><pre>.em-animate .em-leave</pre></td><td><pre>.em-leave-active</pre></td>
            </tr>
          </table>

          <aside class="notes">
            <p>CSS3: Take an Angular ng-animate approach and use css classes for animation setup and execution - my preferred approach</p>
          </aside>
        </section>


        <section>
          <header>
            <h2>Collections</h2>
          </header>
      
          <p>Instead of animating <code class="darken">currentView</code>, animate all the views!</p>
          <br>
          <p>Override CollectionView's <code class="darken">arrayWillChange</code> and <code class="darken">arrayDidChange</code></p>
              
          <aside class="notes">
          </aside>
        </section>

        <section>
          <header>
            <h2>Collections</h2>
          </header>
          
          <a class="jsbin jsbin-embed" href="http://jsbin.com/AKuYOKO/4/embed?live,javascript&height=400px">Edit this example</a>

          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2>Caveats and Gotchas</h2>
          <h4>not quite production ready yet...</h4>
          <ul>
            <li>Container Destruction: <span class="darken">Active animations will interact with destroyed views</span></li>
            <li>Animation Queues: <span class="darken">Cancel active animation when a second is triggered</span></li>
            <li>Initial State: <span class="darken">How should view / collection items that start in container be handled?</span></li>
            <li>Deferred destruction: <span class="darken">Two views on the DOM at once</span></li>
          </ul>
        </section>

        <section>
          <h2>Wrapping Up</h2>
          <ul>
            <li>Manipulating view lifecycle in a ContainerView is easy...but it means overwriting existing functions</li>
            <li>This approach means the Container will <em>always</em> animate (back button!)</li>
            <li>Use CSS 3 transitions</li>
          </ul>
        </section>

        <section>
          <h1>That's It</h1>
          <footer>
            <a href="">Follow me on Twitter</a>
          </footer>
        </section>


      </div>

    </div>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
